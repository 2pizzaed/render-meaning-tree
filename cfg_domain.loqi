//-------------------STATIC (CLASS) SECTION-------------------
//------------------------------------------------------------

enum OriginType {
	parent [
		RU.localizedName = "родительский" ;
		EN.localizedName = "parent" ;
	
	],
	previous [
		RU.localizedName = "предыдущий" ;
		EN.localizedName = "previous" ;
	
	],
} [
	RU.localizedName = "тип происхождения" ;
	EN.localizedName = "origin type" ;

]

enum InterruptionType {
	break [
		RU.localizedName = "прерывание цикла" ;
		EN.localizedName = "break" ;
	
	],
	continue [
		RU.localizedName = "продолжение цикла" ;
		EN.localizedName = "continue" ;
	
	],
	return [
		RU.localizedName = "возврат" ;
		EN.localizedName = "return" ;
	
	],
	exception [
		RU.localizedName = "исключение" ;
		EN.localizedName = "exception" ;
	
	],
	any [
		RU.localizedName = "любое" ;
		EN.localizedName = "any" ;

	],
	none [
		RU.localizedName = "нет прерывания" ;
		EN.localizedName = "none" ;

	],
} [
	RU.localizedName = "тип прерывания" ;
	EN.localizedName = "interruption type" ;

]

enum AppearanceType {
	mandatory [
		RU.localizedName = "обязательный" ;
		EN.localizedName = "mandatory" ;
	
	],
	none [
		RU.localizedName = "не показывать" ;
		EN.localizedName = "none" ;
	
	],
} [
	RU.localizedName = "тип отображения" ;
	EN.localizedName = "appearance type" ;

]

enum CallStackAction {
	add_frame [
		RU.localizedName = "добавление фрейма функции" ;
		EN.localizedName = "add frame" ;
	
	],
	drop_frame [
		RU.localizedName = "удаление фрейма функции" ;
		EN.localizedName = "drop frame" ;
	
	],
} [
	RU.localizedName = "действие стека вызовов" ;
	EN.localizedName = "call stack action" ;

]


class State {
	obj prop interruption_state: InterruptionType ;

	rel hasLastConditionAction(ActionSpec) : {* -> 1}; 
	// + значение этого условия (T/F) ???
}


class Effect {
	obj prop interruption_stop: InterruptionType ;
	obj prop interruption_start: InterruptionType ;
	obj prop call_stack: CallStackAction ;
} [
	RU.localizedName = "эффект" ;
	EN.localizedName = "effect" ;

]


class Behaviour {
	obj prop assumed_value: bool ;
} [
	RU.localizedName = "поведение" ;
	EN.localizedName = "behaviour" ;

]

class Constraint {
	obj prop condition_value: bool ;
	obj prop interruption_mode: InterruptionType ;
} [
	RU.localizedName = "ограничение" ;
	EN.localizedName = "constraint" ;

]

class ActionSpec {
	obj prop role: string ;
	obj prop generalization: string ;
	obj prop kind: string ;

	rel hasEffects(Effect) ;
	rel hasIdentification(Identification) : {* -> 1} ;
	rel hasBehaviour(Behaviour) : {* -> 1} ;
} [
	RU.localizedName = "спецификация действия" ;
	EN.localizedName = "action specification" ;

]

class TransitionSpec {
	obj prop from_: string ;
	obj prop to_: string ;
	obj prop to_when_absent: string ;

	rel hasConstraints(Constraint) ;
	rel hasEffects(Effect) ;
} [
	RU.localizedName = "спецификация перехода" ;
	EN.localizedName = "transition specification" ;

]

class ConstructSpec {
	obj prop name: string ;
	obj prop kind: string ;

	rel hasActions(ActionSpec) ;
	rel hasTransitions(TransitionSpec) ;
	rel belongsToNode(ASTNodeWrapper) : {* -> 1} ;
	rel hasEffects(Effect) ;
} [
	RU.localizedName = "спецификация конструкции" ;
	EN.localizedName = "construct specification" ;

]

class Metadata {
	obj prop assumed_value: bool ;
	obj prop primary: bool ;
	obj prop is_after_last: bool ;
	obj prop call_count: int[0, 65536] ;

	rel hasAbstractAction(ActionSpec) : {* -> 1} ;
	rel belongsToNode(ASTNodeWrapper) : {* -> 1} ;
	rel hasAbstractTransition(TransitionSpec) : {* -> 1} ;
} [
	RU.localizedName = "метаданные" ;
	EN.localizedName = "metadata" ;

]

class Node {
	obj prop id: string ;
	obj prop role: string ;
	obj prop kind: string ;

	rel belongsTo(CFG) : opposite to CFG->hasNodes ;
	rel hasEffects(Effect) ;
	rel hasMetadata(Metadata) : {1 -> 1};

	rel hasEdges(Edge) : opposite to Edge->hasEndpointNode ;
	rel isAccessibleFrom(Node) : {* -> *};
} [
	RU.localizedName = "узел" ;
	EN.localizedName = "node" ;
]

enum EdgeEndpointType {
	source [
		RU.localizedName = "выход" ;
		EN.localizedName = "tail" ;
	
	],
	target [
		RU.localizedName = "вход" ;
		EN.localizedName = "head" ;
	
	],
} [
	RU.localizedName = "тип окончания ребра" ;
	EN.localizedName = "edge endpoint type" ;
]

class Edge {
	obj prop id: string ;
	obj prop src: string ;
	obj prop dst: string ;
	obj prop oriented: bool ;

	rel belongsTo(CFG) : opposite to CFG->hasEdges ;
	rel hasEndpointNode<type: EdgeEndpointType>(Node) : {* -> 2} ;
	rel hasMetadata(Metadata) : {1 -> 1};
	rel hasEffects(Effect) ;
	rel hasConstraints(Constraint) ;
} [
	RU.localizedName = "ребро" ;
	EN.localizedName = "edge" ;

]

class CFG {
	obj prop id: string ;
	obj prop name: string ;

	rel hasNodes(Node) : {1 -> *} ;
	rel hasEdges(Edge) : {1 -> *} ;
	rel hasBegin(Node) : {1 -> 1} ;
	rel hasEnd(Node) : {1 -> 1} ;
} [
	RU.localizedName = "граф потока управления" ;
	EN.localizedName = "control flow graph" ;

]

class ASTNodeWrapper {
	obj prop ast_node: string ;

	rel hasParent(ASTNodeWrapper) : {1 -> 1} ;
	rel hasChildren(ASTNodeWrapper) ;
	rel hasMetadata(Metadata) : {1 -> 1};
} [
	RU.localizedName = "обёртка узла AST" ;
	EN.localizedName = "AST node wrapper" ;

]



class ReachInfo {
	obj prop from_: string ;
	obj prop to: string ;
	obj prop ways_count: int[0, 65536] ;
	obj prop cfg_steps: int[0, 65536] ;
	obj prop ast_actions: int[0, 65536] ;
	obj prop transparent_actions: int[0, 65536] ;
	obj prop opaque_actions: int[0, 65536] ;
	obj prop conditions: int[0, 65536] ;
	obj prop frame_changes: int[0, 65536] ;
	obj prop frames_added: int[0, 65536] ;
	obj prop frames_dropped: int[0, 65536] ;

	rel describesPath(Node, Node) : {1 -> 2} ;
} [
	RU.localizedName = "информация о достижимости" ;
	EN.localizedName = "reachability info" ;

]


//-----------------------OBJECT SECTION-----------------------
	// EXAMPLES !!!
//------------------------------------------------------------


obj beginAction : ActionSpec {
	role = "BEGIN" ;
	generalization = "" ;
	kind = "" ;

} [
	RU.localizedName = "действие начала" ;
	EN.localizedName = "begin action" ;

]

obj endAction : ActionSpec {
	role = "END" ;
	generalization = "" ;
	kind = "" ;
} [
	RU.localizedName = "действие конца" ;
	EN.localizedName = "end action" ;

]

obj emptyMetadata : Metadata {
	assumed_value = false ;
	primary = false ;
	is_after_last = false ;
	call_count = 0 ;

	hasAbstractAction(beginAction) ;
} [
	RU.localizedName = "пустые метаданные" ;
	EN.localizedName = "empty metadata" ;

]

obj emptyIdentification : Identification {
	origin = OriginType:parent ;
	property = "" ;
	property_path = "" ;
} [
	RU.localizedName = "пустая идентификация" ;
	EN.localizedName = "empty identification" ;

]

obj emptyBehaviour : Behaviour {
	assumed_value = false ;
} [
	RU.localizedName = "пустое поведение" ;
	EN.localizedName = "empty behaviour" ;

]

obj emptyConstraints : Constraint {
	condition_value = true ;
	interruption_mode = InterruptionType:any ;
} [
	RU.localizedName = "пустое ограничение" ;
	EN.localizedName = "empty constraint" ;

]

obj emptyEffect : Effect {
	interruption_stop = InterruptionType:break ;
	interruption_start = InterruptionType:break ;
	call_stack = CallStackAction:add_frame ;
} [
	RU.localizedName = "пустой эффект" ;
	EN.localizedName = "empty effect" ;
]

obj defaultKindChain : KindChain {
	chain = "" ;
} [
	RU.localizedName = "пустая цепочка типов" ;
	EN.localizedName = "empty kind chain" ;

]

obj defaultAppearanceProfile : AppearanceProfile {
	name = "default" ;
	checks = "" ;

	hasAppearanceType(AppearanceType:mandatory) ;
} [
	RU.localizedName = "профиль отображения по умолчанию" ;
	EN.localizedName = "default appearance profile" ;

]

obj emptyReachInfo : ReachInfo {
	from_ = "" ;
	to = "" ;
	ways_count = 0 ;
	cfg_steps = 0 ;
	ast_actions = 0 ;
	transparent_actions = 0 ;
	opaque_actions = 0 ;
	conditions = 0 ;
	frame_changes = 0 ;
	frames_added = 0 ;
	frames_dropped = 0 ;
} [
	RU.localizedName = "пустая информация о достижимости" ;
	EN.localizedName = "empty reachability info" ;

]
